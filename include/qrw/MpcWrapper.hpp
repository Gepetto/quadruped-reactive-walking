///////////////////////////////////////////////////////////////////////////////////////////////////
///
/// \brief This is the header for MpcWrapper class
///
/// \details Handle the communication between the main control loop and the MPC
///
//////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef MPCWRAPPER_H_INCLUDED
#define MPCWRAPPER_H_INCLUDED

// #include <string>
// #include <boost/interprocess/managed_shared_memory.hpp>
// #include <boost/interprocess/shared_memory_object.hpp>
// #include <boost/interprocess/mapped_region.hpp>
#include "pinocchio/math/rpy.hpp"
#include <Eigen/Core>
#include <Eigen/Dense>
#include <chrono>
#include <thread>
#include <mutex>
#include "qrw/Types.h"
#include "qrw/MPC.hpp"

// Functions acting on shared memory
void stop_thread();
bool check_stop_thread();
void write_in(int & k, MatrixN & xref, MatrixN & fsteps);
bool read_in(int & k, MatrixN & xref, MatrixN & fsteps);
void write_out(MatrixN & result);
bool check_new_result();
MatrixN read_out();
void parallel_loop();


class MpcWrapper {
 public:
  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Constructor
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  MpcWrapper();

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Initialize with given data
  ///
  /// \param[in] params Object that stores parameters
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  void initialize(Params& params);

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Destructor
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  ~MpcWrapper() {}  // Empty destructor

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Send data to the MPC to solve one iteration of MPC
  ///
  /// \param[in] robot Pointer to the robot interface
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  void solve(int k, MatrixN xref, MatrixN fsteps, MatrixN gait);

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Return the latest available result of the MPC
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double, 24, 2> get_latest_result();

 private:
  
  Params* params_;
  MPC mpc_;

  int test = 0;
  Eigen::Matrix<double, 24, 2> last_available_result;
  Matrix14 gait_past;
  Matrix14 gait_next;

};

#endif  // MPCWRAPPER_H_INCLUDED
