///////////////////////////////////////////////////////////////////////////////////////////////////
///
/// \brief This is the header for MpcWrapper class
///
/// \details Handle the communication between the main control loop and the MPC
///
//////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef MPCWRAPPER_H_INCLUDED
#define MPCWRAPPER_H_INCLUDED

#include <string>
#include <boost/interprocess/managed_shared_memory.hpp>
// #include <boost/interprocess/shared_memory_object.hpp>
// #include <boost/interprocess/mapped_region.hpp>
#include "pinocchio/math/rpy.hpp"
#include <Eigen/Core>
#include <Eigen/Dense>
#include <chrono>
#include <thread>
#include "qrw/Types.h"
#include "qrw/MPC.hpp"

namespace bi = boost::interprocess;

class MpcWrapper {
 public:
  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Constructor
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  MpcWrapper();

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Initialize with given data
  ///
  /// \param[in] params Object that stores parameters
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  void initialize(Params& params);

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Destructor
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  ~MpcWrapper() {}  // Empty destructor

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Send data to the MPC to solve one iteration of MPC
  ///
  /// \param[in] robot Pointer to the robot interface
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  void solve(int k, MatrixN const& xref, MatrixN const& fsteps, MatrixN const& gait);

  ////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// \brief Return the latest available result of the MPC
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double, 24, 2> get_latest_result();

  void run_MPC_asynchronous(int k, MatrixN const& xref, MatrixN const& fsteps);
  void create_MPC_asynchronous();
  //static int check_memory();

 private:
  
  Params* params_;
  MPC mpc_;

  // shared_memory_object shm (boost::interprocess::create_only, "MySharedMemory", boost::interprocess::read_write);
  // mapped_region region;

  bi::managed_shared_memory segment;
  int* shared_k;
  MatrixN* shared_xref;
  MatrixN* shared_fsteps;

  int test = 0;
  Eigen::Matrix<double, 24, 2> last_available_result;
  Matrix14 gait_past;
  Matrix14 gait_next;

};

#endif  // MPCWRAPPER_H_INCLUDED
